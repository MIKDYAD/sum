<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>=sum: глитч-партитура</title>
<style>
  :root{
    --bg:#0b0c0f;
    --fg:#e8e9eb;
    --muted:#9aa0a6;
    --frame:#13151b;
    --accent:#7aa2ff;
    --size:min(90vmin, 840px);
    --pad:16px;
  }
  @media (max-width: 768px){
    :root{ --size:min(92vmin, 640px); --pad:12px; }
  }
  @media (max-width: 480px){
    :root{ --size:min(94vmin, 420px); --pad:10px; }
  }
  @media (max-width: 480px){
  .hud{ left:50%; right:auto; transform:translateX(-50%); bottom: max(10px, env(safe-area-inset-bottom, 0px)); }
}


  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font:15px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}
  /* было: .wrap{min-height:100%;display:grid;place-items:center;padding:clamp(12px,2.5vmin,24px)} */
.wrap{
  min-height:100dvh;
  display:grid;
  place-items:center;
  padding: max(12px, 2.5vmin);
  padding-top: calc(max(12px, 2.5vmin) + env(safe-area-inset-top, 0px));
  padding-right: calc(max(12px, 2.5vmin) + env(safe-area-inset-right, 0px));
  padding-bottom: calc(max(12px, 2.5vmin) + env(safe-area-inset-bottom, 0px));
  padding-left: calc(max(12px, 2.5vmin) + env(safe-area-inset-left, 0px));
}

/* было: .stage-frame{ width:calc(var(--size) + var(--pad)*2); height:calc(var(--size)+var(--pad)*2); } */
.stage-frame{
  inline-size: fit-content;
  block-size: fit-content;
  max-inline-size: calc(100vw - (env(safe-area-inset-left,0px) + env(safe-area-inset-right,0px) + 24px));
  max-block-size:  calc(100dvh - (env(safe-area-inset-top,0px)  + env(safe-area-inset-bottom,0px) + 24px));
  padding: var(--pad);
  /* остальной стиль рамки оставить как было */
}

/* квадрат внутри рамки получает авто-ограничение */
.stage-inner{
  width: var(--size);
  height: var(--size);
  max-width: calc(100vw - (env(safe-area-inset-left,0px) + env(safe-area-inset-right,0px) + 48px));
  max-height: calc(100dvh - (env(safe-area-inset-top,0px) + env(safe-area-inset-bottom,0px) + 48px));
  aspect-ratio: 1 / 1;
  /* остальное без изменений */
}

  canvas#stage{display:block;width:100%;height:100%;image-rendering:auto;background:#000}
  .glow{
    position:absolute;inset:-12% -12%;
    pointer-events:none;mix-blend-mode:color-dodge;opacity:.35;
    background:
      radial-gradient(120% 90% at 20% 10%, rgba(255,120,120,.25) 0%, transparent 60%),
      radial-gradient(100% 80% at 90% 20%, rgba(120,255,180,.18) 0%, transparent 60%),
      radial-gradient(100% 100% at 50% 90%, rgba(120,160,255,.22) 0%, transparent 70%);
    filter: blur(18px) saturate(160%);
  }
  .grain{
    position:absolute;inset:0;pointer-events:none;opacity:.12;mix-blend-mode:soft-light;
    background-image:repeating-conic-gradient(from 0deg, rgba(255,255,255,.015) 0% 0.25%, transparent 0.25% 0.5%);
    animation:grainShift 8s linear infinite;
  }
  @keyframes grainShift{ 0%{transform:translate3d(0,0,0)} 100%{transform:translate3d(-2%,1%,0)} }

  .hud{
    position:fixed;left:12px;bottom:12px;right:auto;
    display:flex;gap:8px;align-items:center;
    background:rgba(10,12,16,.6);backdrop-filter:blur(6px);
    border:1px solid #222630;padding:8px 10px;border-radius:10px
  }
  .hud button{all:unset;cursor:pointer;background:#151821;border:1px solid #232633;color:var(--fg);padding:6px 10px;border-radius:8px}
  .hud .stat{color:var(--muted)}
  @media (max-width:480px){
    .hud{left:50%;transform:translateX(-50%);bottom:10px}
  }

  /* Уважение системной настройки "меньше анимации" */
  @media (prefers-reduced-motion: reduce){
    .grain{animation:none}
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="stage-frame" aria-label="рамка холста">
    <div class="stage-inner" id="stageInner">
      <canvas id="stage" width="512" height="512"></canvas>
      <div class="glow"></div>
      <div class="grain"></div>
    </div>
  </div>
</div>

<div class="hud">
  <button id="toggle">Пауза</button>
  <button id="reroll">Новая волна</button>
  <span class="stat" id="info">загрузка…</span>
</div>

<script>
(()=>{
// ---------- Конфиг и адаптация ----------
const WORKS=9, LAYERS=8;
const IMG=(w,l)=>`assets/layers/W${w}/${String(l).padStart(2,'0')}.png`;

// Адаптивный лимит DPR и рендер‑сложности
const isMobile = /Android|iPhone|iPad|iPod|Opera Mini|IEMobile/i.test(navigator.userAgent);
let DPR = Math.min(isMobile ? 1.5 : 2, Math.max(1, window.devicePixelRatio||1)); // сглаживаем нагрузку [web:194]
let MAX_SPRITES = isMobile ? 12 : 18;
let RETARGET_EVERY = isMobile ? 2600 : 2200;

const canvas = document.getElementById('stage');
const inner  = document.getElementById('stageInner');
const ctx = canvas.getContext('2d', { alpha:false, desynchronized:true });

// Учитываем prefers-reduced-motion: замедляем и упрощаем [web:198]
const prf = window.matchMedia('(prefers-reduced-motion: reduce)');
if (prf.matches){ MAX_SPRITES = Math.floor(MAX_SPRITES*0.6); RETARGET_EVERY *= 1.5; }

// ResizeObserver — точнее чем событие resize
const ro = new ResizeObserver(()=> fitSquare());
ro.observe(inner);

function fitSquare(){
  const inner = document.getElementById('stageInner');
  const rect = inner.getBoundingClientRect();
  // используем меньшую из сторон и страхуемся от отрицательных значений
  const cssSize = Math.max(50, Math.floor(Math.min(rect.width, rect.height)));
  const dpr = Math.min(2, Math.max(1, window.devicePixelRatio || 1));
  canvas.style.width  = cssSize + 'px';
  canvas.style.height = cssSize + 'px';
  canvas.width  = Math.floor(cssSize * dpr);
  canvas.height = Math.floor(cssSize * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';
}


// ---------- Стохастика ----------
let seed = Math.floor(Math.random()*1e9);
function rand(){ seed|=0; seed = seed + 0x6D2B79F5 | 0; let t = Math.imul(seed ^ seed >>> 15, 1 | seed); t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t; return ((t ^ t >>> 14) >>> 0) / 4294967296; }
function rint(a,b){return Math.floor(rand()*(b-a+1))+a}
function rpick(a){return a[rint(0,a.length-1)]}
function lerp(a,b,t){return a+(b-a)*t}
function ease(t){return t<.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2}
function n1(t, sp=1){return Math.sin(t*sp*0.0007)+Math.sin(t*sp*0.0013+1.7)+Math.cos(t*sp*0.0009+0.3)}

// ---------- Загрузка с таймаутом и «первой волной» ----------
const BLENDS=['source-over','lighter','screen','overlay','color-dodge','plus-lighter','soft-light','difference','exclusion','multiply'];
const SOURCES = Array.from({length:WORKS},(_,i)=>i+1).flatMap(w=>Array.from({length:LAYERS},(_,l)=>IMG(w,l+1)));
const FIRST_WAVE = isMobile ? 9 : 12;
const TIMEOUT_MS  = 12000;

const images=[]; let loaded=0, started=false;
const info = document.getElementById('info');

function loadImageWithTimeout(src, timeout=TIMEOUT_MS){
  return new Promise((resolve, reject)=>{
    const img = new Image();
    let done=false;
    const to = setTimeout(()=>{ if(done) return; done=true; reject(new Error('timeout '+src)); }, timeout);
    img.onload = ()=>{ if(done) return; done=true; clearTimeout(to); img.decode?.().finally(()=>resolve(img)); };
    img.onerror= ()=>{ if(done) return; done=true; clearTimeout(to); reject(new Error('error '+src)); };
    img.src = src;
  });
}

async function loadProgressive(){
  // первая волна для старта
  const first = SOURCES.slice(0, Math.min(FIRST_WAVE, SOURCES.length)).map(src =>
    loadImageWithTimeout(src).then(img=>{ images.push(img); loaded++; info.textContent=`загружено ${loaded}/${SOURCES.length}`; })
                              .catch(()=>{ loaded++; info.textContent=`загружено ${loaded}/${SOURCES.length}`; })
  );
  await Promise.allSettled(first);
  if(images.length>0 && !started){ started=true; startRender(); }
  // остальное — фоном
  const rest = SOURCES.slice(FIRST_WAVE).map(src =>
    loadImageWithTimeout(src).then(img=>{ images.push(img); loaded++; info.textContent=`загружено ${loaded}/${SOURCES.length}`; })
                              .catch(()=>{ loaded++; info.textContent=`загружено ${loaded}/${SOURCES.length}`; })
  );
  Promise.allSettled(rest).then(()=> info.textContent=`готово: ${loaded}/${SOURCES.length}`);
}

// ---------- Спрайты ----------
class Sprite{
  constructor(img){ this.img=img; this.reset(true); }
  reset(init=false){
    const t=performance.now();
    if(init){ this.x=0; this.y=0; this.s=1; this.r=0; this.a=.6; this.blend='source-over'; this.inv=0; }
    this.tx = rint(-140,140);
    this.ty = rint(-140,140);
    this.ts = 0.5 + rand()*1.6;
    this.tr = (rand()*Math.PI*2) * (rand()<0.5?1:0.25);
    this.ta = 0.25 + rand()*0.75;
    this.tblend = rpick(BLENDS);
    this.tinv = rand()<0.22 ? 1 : 0;
    this.tStart = t;
    this.tEnd = t + RETARGET_EVERY + rint(-600,600);
  }
  step(now){
    const k = Math.min(1, (now - this.tStart)/(this.tEnd - this.tStart));
    const e = ease(k);
    this.x = lerp(this.x, this.tx, e*0.08);
    this.y = lerp(this.y, this.ty, e*0.08);
    this.s = lerp(this.s, this.ts, e*0.08);
    this.r = lerp(this.r, this.tr, e*0.08);
    this.a = lerp(this.a, this.ta, e*0.08);
    if(k>=1) this.reset();
  }
  draw(now){
    const W=canvas.width/DPR, H=canvas.height/DPR;
    const dw=this.img.width*this.s, dh=this.img.height*this.s;
    ctx.save();
    ctx.translate(W/2 + this.x + Math.sin(now*0.0006)*20, H/2 + this.y + Math.cos(now*0.0005)*20);
    ctx.rotate(this.r + Math.sin(now*0.0003)*0.15);
    if(rand()<0.08) ctx.scale(-1,1);
    ctx.globalCompositeOperation = this.tblend;
    ctx.globalAlpha = this.a;

    const inv = this.tinv ? 'invert(1)' : 'invert(0)';
    const sat = `saturate(${isMobile?150:180 + Math.floor(80*Math.sin(now*0.0008))}%)`;
    const con = `contrast(${120 + Math.floor(60*Math.cos(now*0.0009))}%)`;
    const hue = `hue-rotate(${Math.floor((n1(now,1)+2)*90)}deg)`;
    const blur= rand()<(isMobile?0.04:0.06) ? `blur(${rint(1,2)}px)` : 'blur(0px)';
    ctx.filter = [inv,hue,sat,con,blur].join(' ');
    ctx.drawImage(this.img, -dw/2, -dh/2, dw, dh);
    ctx.restore();

    if(rand()<(isMobile?0.04:0.06)){
      const slices = rint(2, isMobile?5:7);
      for(let i=0;i<slices;i++){
        const sy = rint(0, this.img.height-1);
        const sh = rint(2, Math.max(4, Math.floor(this.img.height*0.05)));
        const jitter = rint(-Math.floor(dw*0.15), Math.floor(dw*0.15));
        ctx.save();
        ctx.globalCompositeOperation = rpick(['difference','exclusion','color-dodge','plus-lighter']);
        ctx.globalAlpha = 0.25 + rand()*0.4;
        ctx.filter = `hue-rotate(${rint(-20,20)}deg) saturate(220%) contrast(130%)`;
        ctx.drawImage(this.img, 0, sy, this.img.width, sh,
          W/2 + this.x - dw/2 + jitter,
          H/2 + this.y - dh/2 + sy*this.s,
          this.img.width*this.s, sh*this.s);
        ctx.restore();
      }
    }
  }
}

// ---------- Сцена и цикл ----------
const sprites=[];
function populate(){
  sprites.length=0;
  const count = Math.min(MAX_SPRITES, Math.max(6, Math.floor(images.length*0.5)));
  for(let i=0;i<count;i++){ sprites.push(new Sprite(images[rint(0,images.length-1)])); }
}
function sceneFilters(now){
  const hue = Math.floor((Math.sin(now*0.0002)+1)*90);
  const sat = 140 + Math.floor(40*Math.sin(now*0.0004+1.3));
  const con = 115 + Math.floor(30*Math.cos(now*0.00033+0.5));
  const brt = 102 + Math.floor(8*Math.sin(now*0.00027));
  ctx.filter = `hue-rotate(${hue}deg) saturate(${sat}%) contrast(${con}%) brightness(${brt}%)`;
}

let running=true;
function tick(ts){
  if(!running){ requestAnimationFrame(tick); return; }
  ctx.setTransform(DPR,0,0,DPR,0,0);
  ctx.globalCompositeOperation='source-over';
  ctx.globalAlpha = 1; ctx.filter='none';
  ctx.fillStyle = '#000'; ctx.fillRect(0,0, canvas.width/DPR, canvas.height/DPR);

  sceneFilters(ts);
  for(const s of sprites){ s.step(ts); s.draw(ts); }

  // Виньетка
  const W=canvas.width/DPR, H=canvas.height/DPR;
  const grd=ctx.createRadialGradient(W/2,H/2,Math.min(W,H)*0.2, W/2,H/2,Math.max(W,H)*0.7);
  grd.addColorStop(0,'rgba(0,0,0,0)');
  grd.addColorStop(1,'rgba(0,0,0,0.18)');
  ctx.filter='none';
  ctx.globalCompositeOperation='multiply';
  ctx.fillStyle=grd; ctx.fillRect(0,0,W,H);

  requestAnimationFrame(tick);
}

// ---------- UI ----------
document.getElementById('toggle').addEventListener('click',()=>{
  running=!running;
  document.getElementById('toggle').textContent = running?'Пауза':'Старт';
});
document.getElementById('reroll').addEventListener('click',()=>{
  seed=Math.floor(Math.random()*1e9);
  populate();
});

// ---------- Запуск ----------
async function startRender(){
  fitSquare();
  populate();
  requestAnimationFrame(tick);
}
(async function init(){
  fitSquare();
  await loadProgressive();
})();
})();
</script>
</body>
</html>
