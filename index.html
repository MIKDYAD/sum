<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>=sum: глитч‑партитура</title>
<style>
  :root{
    --bg:#0b0c0f;
    --fg:#e8e9eb;
    --muted:#9aa0a6;
    --frame:#13151b;
    --accent:#7aa2ff;
    --size:min(90vmin, 840px);
    --pad:20px;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font:15px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}
  .wrap{min-height:100%;display:grid;place-items:center;padding:24px}
  .stage-frame{
    width:calc(var(--size) + var(--pad)*2);
    height:calc(var(--size) + var(--pad)*2);
    background:
      linear-gradient(180deg,#191c24,#0e1116) padding-box,
      linear-gradient(135deg,rgba(255,255,255,.12),rgba(122,162,255,.35),rgba(255,255,255,.08)) border-box;
    border:1.5px solid transparent;
    border-radius:16px;
    box-shadow:
      inset 0 0 0 1px rgba(255,255,255,.06),
      0 8px 30px rgba(0,0,0,.45);
    display:grid;place-items:center;position:relative;
  }
  .stage-inner{
    width:var(--size);height:var(--size);
    position:relative;border-radius:12px;overflow:hidden;
    box-shadow:inset 0 0 0 1px rgba(255,255,255,.05);
    background:#000;
  }
  canvas#stage{display:block;width:100%;height:100%;image-rendering:auto;background:#000}
  /* Светящийся оверлей для «суперсияния» */
  .glow{
    position:absolute;inset:-10% -10%;
    pointer-events:none;mix-blend-mode:color-dodge;opacity:.35;
    background:
      radial-gradient(120% 90% at 20% 10%, rgba(255,120,120,.25) 0%, transparent 60%),
      radial-gradient(100% 80% at 90% 20%, rgba(120,255,180,.18) 0%, transparent 60%),
      radial-gradient(100% 100% at 50% 90%, rgba(120,160,255,.22) 0%, transparent 70%);
    filter: blur(18px) saturate(160%);
  }
  /* Плёночная зернистость */
  .grain{
    position:absolute;inset:0;pointer-events:none;opacity:.12;mix-blend-mode:soft-light;
    background-image:
      repeating-conic-gradient(from 0deg, rgba(255,255,255,.015) 0% 0.25%, transparent 0.25% 0.5%);
    animation:grainShift 8s linear infinite;
  }
  @keyframes grainShift{
    0%{transform:translate3d(0,0,0)}
    100%{transform:translate3d(-2%,1%,0)}
  }
  .hud{
    position:fixed;left:16px;bottom:16px;
    display:flex;gap:8px;align-items:center;
    background:rgba(10,12,16,.6);backdrop-filter:blur(6px);
    border:1px solid #222630;padding:8px 10px;border-radius:10px
  }
  .hud button{all:unset;cursor:pointer;background:#151821;border:1px solid #232633;color:var(--fg);padding:6px 10px;border-radius:8px}
  .hud .stat{color:var(--muted)}
</style>
</head>
<body>
<div class="wrap">
  <div class="stage-frame" aria-label="рамка холста">
    <div class="stage-inner">
      <canvas id="stage" width="1024" height="1024"></canvas>
      <div class="glow"></div>
      <div class="grain"></div>
    </div>
  </div>
</div>

<div class="hud">
  <button id="toggle">Пауза</button>
  <button id="reroll">Новая волна</button>
  <span class="stat" id="info">загрузка…</span>
</div>

<script>
(()=>{
// ---------- Конфиг ----------
const WORKS=9, LAYERS=8;
const IMG=(w,l)=>`assets/layers/W${w}/${String(l).padStart(2,'0')}.png`;
const BLENDS=['source-over','lighter','screen','overlay','color-dodge','plus-lighter','soft-light','difference','exclusion','multiply'];
const DPR = Math.min(2, Math.max(1, window.devicePixelRatio||1));
const MAX_SPRITES = 18;
const RETARGET_EVERY = 2200;

// Явно выбираем canvas и контекст
const canvas = document.getElementById('stage');
const ctx = canvas.getContext('2d', { alpha:false, desynchronized:true });

// ---------- Стохастика ----------
let seed = Math.floor(Math.random()*1e9);
function rand(){ // Mulberry32
  seed |= 0; seed = seed + 0x6D2B79F5 | 0;
  let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
  t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
  return ((t ^ t >>> 14) >>> 0) / 4294967296;
}
function rint(a,b){return Math.floor(rand()*(b-a+1))+a}
function rpick(a){return a[rint(0,a.length-1)]}
function lerp(a,b,t){return a+(b-a)*t}
function ease(t){return t<.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2}
function n1(t, sp=1){return Math.sin(t*sp*0.0007)+Math.sin(t*sp*0.0013+1.7)+Math.cos(t*sp*0.0009+0.3)}

// ---------- Загрузка PNG слоёв (без 404) ----------
const images=[];
async function loadAll(){
  const jobs=[];
  for(let w=1; w<=WORKS; w++){
    for(let l=1; l<=LAYERS; l++){
      const src = IMG(w,l);
      jobs.push(new Promise((resolve, reject)=>{
        const img = new Image();
        img.decoding='sync'; img.loading='eager';
        img.onload = ()=> (img.naturalWidth>0 ? resolve(img) : reject(new Error('empty '+src)));
        img.onerror = ()=> reject(new Error('load-failed '+src));
        img.src = src;
      }));
    }
  }
  const res = await Promise.allSettled(jobs);
  for(const r of res){ if(r.status==='fulfilled') images.push(r.value); }
  if(images.length===0){
    document.getElementById('info').textContent='Нет загруженных PNG: проверьте assets/layers/W*/**.png';
    throw new Error('no-images');
  }
}

// ---------- Квадратный размер по реальной геометрии ----------
function fitSquare(){
  const inner = document.querySelector('.stage-inner');
  const rect = inner.getBoundingClientRect();
  const s = Math.floor(Math.min(rect.width, rect.height));
  canvas.style.width = s+'px';
  canvas.style.height = s+'px';
  canvas.width  = Math.floor(s * DPR);
  canvas.height = Math.floor(s * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';
}
window.addEventListener('resize', fitSquare);

// ---------- Спрайты с плавным «дрейфом» ----------
class Sprite{
  constructor(img){ this.img=img; this.reset(true); }
  reset(init=false){
    const t=performance.now();
    if(init){ this.x=0; this.y=0; this.s=1; this.r=0; this.a=.6; this.blend='source-over'; this.inv=0; }
    this.tx = rint(-140,140);
    this.ty = rint(-140,140);
    this.ts = 0.5 + rand()*1.6;
    this.tr = (rand()*Math.PI*2) * (rand()<0.5?1:0.25);
    this.ta = 0.25 + rand()*0.75;
    this.tblend = rpick(BLENDS);
    this.tinv = rand()<0.22 ? 1 : 0;
    this.tStart = t;
    this.tEnd = t + RETARGET_EVERY + rint(-600,600);
  }
  step(now){
    const k = Math.min(1, (now - this.tStart)/(this.tEnd - this.tStart));
    const e = ease(k);
    this.x = lerp(this.x, this.tx, e*0.08);
    this.y = lerp(this.y, this.ty, e*0.08);
    this.s = lerp(this.s, this.ts, e*0.08);
    this.r = lerp(this.r, this.tr, e*0.08);
    this.a = lerp(this.a, this.ta, e*0.08);
    if(k>=1) this.reset();
  }
  draw(now){
    const W=canvas.width/DPR, H=canvas.height/DPR;
    const dw=this.img.width*this.s, dh=this.img.height*this.s;
    ctx.save();
    ctx.translate(W/2 + this.x + Math.sin(now*0.0006)*20, H/2 + this.y + Math.cos(now*0.0005)*20);
    ctx.rotate(this.r + Math.sin(now*0.0003)*0.15);
    if(rand()<0.1) ctx.scale(-1,1);
    ctx.globalCompositeOperation = this.tblend;
    ctx.globalAlpha = this.a;

    const inv = this.tinv ? 'invert(1)' : 'invert(0)';
    const sat = `saturate(${180 + Math.floor(80*Math.sin(now*0.0008))}%)`;
    const con = `contrast(${120 + Math.floor(60*Math.cos(now*0.0009))}%)`;
    const hue = `hue-rotate(${Math.floor((n1(now,1)+2)*90)}deg)`;
    const blur= rand()<0.06 ? `blur(${rint(1,2)}px)` : 'blur(0px)';
    ctx.filter = [inv,hue,sat,con,blur].join(' ');

    ctx.drawImage(this.img, -dw/2, -dh/2, dw, dh);
    ctx.restore();

    if(rand()<0.06){
      const slices = rint(3,7);
      for(let i=0;i<slices;i++){
        const sy = rint(0, this.img.height-1);
        const sh = rint(2, Math.max(4, Math.floor(this.img.height*0.05)));
        const jitter = rint(-Math.floor(dw*0.15), Math.floor(dw*0.15));
        ctx.save();
        ctx.globalCompositeOperation = rpick(['difference','exclusion','color-dodge','plus-lighter']);
        ctx.globalAlpha = 0.25 + rand()*0.4;
        ctx.filter = `hue-rotate(${rint(-20,20)}deg) saturate(220%) contrast(130%)`;
        ctx.drawImage(this.img, 0, sy, this.img.width, sh,
          W/2 + this.x - dw/2 + jitter,
          H/2 + this.y - dh/2 + sy*this.s,
          this.img.width*this.s, sh*this.s);
        ctx.restore();
      }
    }
  }
}

// ---------- Сцена ----------
const sprites=[];
function populate(){
  sprites.length=0;
  for(let i=0;i<MAX_SPRITES;i++){
    sprites.push(new Sprite(images[rint(0,images.length-1)]));
  }
}
function sceneFilters(now){
  const hue = Math.floor((Math.sin(now*0.0002)+1)*90);
  const sat = 140 + Math.floor(40*Math.sin(now*0.0004+1.3));
  const con = 115 + Math.floor(30*Math.cos(now*0.00033+0.5));
  const brt = 102 + Math.floor(8*Math.sin(now*0.00027));
  ctx.filter = `hue-rotate(${hue}deg) saturate(${sat}%) contrast(${con}%) brightness(${brt}%)`;
}

// ---------- Цикл ----------
let running=true, last=0;
const info=document.getElementById('info');
function tick(ts){
  if(!running){ requestAnimationFrame(tick); return; }
  if(!last) last=ts;

  ctx.setTransform(DPR,0,0,DPR,0,0);
  ctx.globalCompositeOperation='source-over';
  ctx.globalAlpha = 1; ctx.filter='none';
  ctx.fillStyle = '#000'; ctx.fillRect(0,0, canvas.width/DPR, canvas.height/DPR);

  sceneFilters(ts);
  for(const s of sprites){ s.step(ts); s.draw(ts); }

  // Виньетка
  const W=canvas.width/DPR, H=canvas.height/DPR;
  const grd=ctx.createRadialGradient(W/2,H/2,Math.min(W,H)*0.2, W/2,H/2,Math.max(W,H)*0.7);
  grd.addColorStop(0,'rgba(0,0,0,0)');
  grd.addColorStop(1,'rgba(0,0,0,0.18)');
  ctx.filter='none';
  ctx.globalCompositeOperation='multiply';
  ctx.fillStyle=grd; ctx.fillRect(0,0,W,H);

  info.textContent=`sprites:${sprites.length} seed:${seed>>>0}`;
  requestAnimationFrame(tick);
}

// ---------- UI ----------
document.getElementById('toggle').addEventListener('click',()=>{
  running=!running;
  document.getElementById('toggle').textContent = running?'Пауза':'Старт';
});
document.getElementById('reroll').addEventListener('click',()=>{
  seed=Math.floor(Math.random()*1e9);
  populate();
});

// ---------- Запуск ----------
(async function init(){
  fitSquare();
  await loadAll();
  populate();
  requestAnimationFrame(tick);
})();
})();
</script>
</body>
</html>
