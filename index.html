<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>=sum</title>
<style>
  :root{
    --bg:#0b0c0f;
    --fg:#e8e9eb;
    --muted:#9aa0a6;
    --accent:#7aa2ff;
    --frame-pad:16px;
    --max-size: 900px;         /* верхний предел квадрата */
  }

  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font:15px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}

  .wrap{
    min-height:100dvh;
    display:grid;
    place-items:center;
    padding: max(12px, 2.5vmin);
    padding-top:    calc(max(12px, 2.5vmin) + env(safe-area-inset-top, 0px));
    padding-right:  calc(max(12px, 2.5vmin) + env(safe-area-inset-right, 0px));
    padding-bottom: calc(max(12px, 2.5vmin) + env(safe-area-inset-bottom, 0px));
    padding-left:   calc(max(12px, 2.5vmin) + env(safe-area-inset-left, 0px));
  } /* учитываем safe-area и реальную высоту окна */

  /* Рамка с подсветкой: всегда видима, не схлопывается */
  .frame{
    box-sizing:border-box;
    padding: var(--frame-pad);
    max-width:  calc(100vw - (env(safe-area-inset-left,0px) + env(safe-area-inset-right,0px) + 24px));
    max-height: calc(100dvh - (env(safe-area-inset-top,0px)  + env(safe-area-inset-bottom,0px) + 24px));
    width: min(92vmin, var(--max-size));
    height: min(92vmin, var(--max-size));
    background:
      linear-gradient(180deg,#191c24,#0e1116) padding-box,
      linear-gradient(135deg,rgba(255,255,255,.12),rgba(122,162,255,.35),rgba(255,255,255,.08)) border-box;
    border:1.5px solid transparent;
    border-radius:16px;
    box-shadow:
      inset 0 0 0 1px rgba(255,255,255,.06),
      0 8px 30px rgba(0,0,0,.45);
    display:grid;place-items:center;position:relative;
  }

  /* Квадратная сцена строго вписывается внутрь рамки */
  .stage{
    position:relative;
    width:100%; height:100%;
    aspect-ratio: 1/1;
    border-radius:12px; overflow:hidden;
    box-shadow:inset 0 0 0 1px rgba(255,255,255,.06);
    background:#000;
    touch-action:none; /* для pan/pinch */
  }

  canvas#stage{display:block;width:100%;height:100%;image-rendering:auto;background:#000}

  /* Светящийся оверлей — даёт «сияние» без нагрузки */
  .glow{
    position:absolute;inset:-12% -12%;
    pointer-events:none;mix-blend-mode:color-dodge;opacity:.35;
    background:
      radial-gradient(120% 90% at 20% 10%, rgba(255,120,120,.25) 0%, transparent 60%),
      radial-gradient(100% 80% at 90% 20%, rgba(120,255,180,.18) 0%, transparent 60%),
      radial-gradient(100% 100% at 50% 90%, rgba(120,160,255,.22) 0%, transparent 70%);
    filter: blur(18px) saturate(160%);
  }

  /* Плёночная зернистость */
  .grain{
    position:absolute;inset:0;pointer-events:none;opacity:.12;mix-blend-mode:soft-light;
    background-image:repeating-conic-gradient(from 0deg, rgba(255,255,255,.015) 0% 0.25%, transparent 0.25% 0.5%);
    animation:grainShift 8s linear infinite;
  }
  @keyframes grainShift{ 0%{transform:translate3d(0,0,0)} 100%{transform:translate3d(-2%,1%,0)} }

  .hud{
    position:fixed;left:12px;bottom:12px;
    display:flex;gap:8px;align-items:center;
    background:rgba(10,12,16,.6);backdrop-filter:blur(6px);
    border:1px solid #222630;padding:8px 10px;border-radius:10px
  }
  .hud button{all:unset;cursor:pointer;background:#151821;border:1px solid #232633;color:var(--fg);padding:6px 10px;border-radius:8px}
  .hud .stat{color:var(--muted)}
  @media (max-width:480px){
    .hud{left:50%;transform:translateX(-50%);bottom: max(10px, env(safe-area-inset-bottom, 0px));}
  }

  /* Доступность: меньше движения — меньше зерна/инерции */
  @media (prefers-reduced-motion: reduce){
    .grain{animation:none}
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="frame" aria-label="подсвеченная рамка">
    <div class="stage" id="stageHost">
      <canvas id="stage" width="512" height="512"></canvas>
      <div class="glow"></div>
      <div class="grain"></div>
    </div>
  </div>
</div>

<div class="hud">
  <button id="toggle">Пауза</button>
  <button id="reroll">Новая волна</button>
  <span class="stat" id="info">загрузка…</span>
</div>

<script>
(()=>{
// ---------- Конфиг ----------
const WORKS=9, LAYERS=8;
const IMG=(w,l)=>`assets/layers/W${w}/${String(l).padStart(2,'0')}.png`;
const BLENDS=['source-over','lighter','screen','overlay','color-dodge','plus-lighter','soft-light','difference','exclusion','multiply'];
const host = document.getElementById('stageHost');
const canvas = document.getElementById('stage');
const ctx = canvas.getContext('2d',{ alpha:false, desynchronized:true });

const isMobile = /Android|iPhone|iPad|iPod|Opera Mini|IEMobile/i.test(navigator.userAgent);
let DPR = Math.min(isMobile?1.5:2, Math.max(1, window.devicePixelRatio||1));
let MAX_SPRITES = isMobile ? 28 : 44;            // больше элементов, но мельче
let BASE_SCALE  = isMobile ? 0.35 : 0.45;        // базовый размер элементов
let RETARGET_MS = isMobile ? 2600 : 2200;

const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
if(prefersReduced){ MAX_SPRITES=Math.floor(MAX_SPRITES*0.6); RETARGET_MS*=1.4; }

// ---------- Респонсив: точный квадрат внутри рамки ----------
function fitSquare(){
  const r = host.getBoundingClientRect();
  const size = Math.max(80, Math.floor(Math.min(r.width, r.height)));
  const dpr  = Math.min(2, Math.max(1, window.devicePixelRatio||1));
  DPR = Math.min(DPR, dpr);
  canvas.style.width  = size+'px';
  canvas.style.height = size+'px';
  canvas.width  = Math.floor(size * DPR);
  canvas.height = Math.floor(size * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';
}
const ro = new ResizeObserver(fitSquare);
ro.observe(host);

// ---------- Стохастика ----------
let seed = Math.floor(Math.random()*1e9);
function rand(){ seed|=0; seed = seed + 0x6D2B79F5 | 0; let t = Math.imul(seed ^ seed >>> 15, 1 | seed); t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t; return ((t ^ t >>> 14) >>> 0) / 4294967296; }
function rint(a,b){return Math.floor(rand()*(b-a+1))+a}
function rpick(a){return a[rint(0,a.length-1)]}
function lerp(a,b,t){return a+(b-a)*t}
function ease(t){return t<.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2}
function n1(t, sp=1){return Math.sin(t*sp*0.0007)+Math.sin(t*sp*0.0013+1.7)+Math.cos(t*sp*0.0009+0.3)}

// ---------- Загрузка (первая волна + фоновая) ----------
const sources = Array.from({length:WORKS},(_,i)=>i+1).flatMap(w=>Array.from({length:LAYERS},(_,l)=>IMG(w,l+1)));
const FIRST_WAVE = isMobile ? 9 : 12;
const TIMEOUT_MS = 12000;
const images=[]; let loaded=0, started=false;
const info = document.getElementById('info');

function loadImageWithTimeout(src, timeout=TIMEOUT_MS){
  return new Promise((resolve, reject)=>{
    const img = new Image();
    let done=false;
    const to = setTimeout(()=>{ if(done) return; done=true; reject(new Error('timeout '+src)); }, timeout);
    img.onload = ()=>{ if(done) return; done=true; clearTimeout(to); img.decode?.().finally(()=>resolve(img)); };
    img.onerror= ()=>{ if(done) return; done=true; clearTimeout(to); reject(new Error('error '+src)); };
    img.src = src;
  });
}

async function loadAllProgressive(){
  const first = sources.slice(0, Math.min(FIRST_WAVE, sources.length)).map(src =>
    loadImageWithTimeout(src).then(img=>{ images.push(img); loaded++; info.textContent=`загружено ${loaded}/${sources.length}`; })
                              .catch(()=>{ loaded++; info.textContent=`загружено ${loaded}/${sources.length}`; })
  );
  await Promise.allSettled(first);
  if(images.length>0 && !started){ started=true; startRender(); }
  const rest = sources.slice(FIRST_WAVE).map(src =>
    loadImageWithTimeout(src).then(img=>{ images.push(img); loaded++; info.textContent=`загружено ${loaded}/${sources.length}`; })
                              .catch(()=>{ loaded++; info.textContent=`загружено ${loaded}/${sources.length}`; })
  );
  Promise.allSettled(rest).then(()=> info.textContent=`готово: ${loaded}/${sources.length}`);
}

// ---------- Камера (пан/пинч/зум с инерцией) ----------
const camera = {
  x: 0, y: 0, z: 1,      // положение и масштаб (z)
  vx: 0, vy: 0, vz: 0,   // скорости для инерции
  friction: prefersReduced ? 0.85 : 0.92,
  zMin: 0.28, zMax: 2.8
};

function zoomAt(px,py, factor){
  const W=canvas.width/DPR, H=canvas.height/DPR;
  const wx = (px - W/2)/camera.z + camera.x;
  const wy = (py - H/2)/camera.z + camera.y;
  const nz = Math.min(camera.zMax, Math.max(camera.zMin, camera.z*factor));
  camera.z = nz;
  camera.x = wx - (px - W/2)/camera.z;
  camera.y = wy - (py - H/2)/camera.z;
}

let pointers = new Map();
let lastDist = null;
host.addEventListener('pointerdown', e=>{
  host.setPointerCapture(e.pointerId);
  pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
  if(pointers.size===1){ camera.vx=0; camera.vy=0; }
});
host.addEventListener('pointermove', e=>{
  const prev = pointers.get(e.pointerId);
  pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
  if(pointers.size===1 && prev){
    const dx = e.clientX - prev.x, dy = e.clientY - prev.y;
    camera.x -= dx / camera.z; camera.y -= dy / camera.z;
    camera.vx = -dx / camera.z; camera.vy = -dy / camera.z;
  }else if(pointers.size>=2){
    const pts = [...pointers.values()];
    const [p0,p1] = pts.slice(0,2);
    const cx = (p0.x + p1.x)/2, cy=(p0.y + p1.y)/2;
    const dist = Math.hypot(p0.x - p1.x, p0.y - p1.y);
    if(lastDist!=null){
      const factor = dist/Math.max(1,lastDist);
      zoomAt(cx, cy, factor);
    }
    lastDist = dist;
  }
});
['pointerup','pointercancel','pointerleave'].forEach(type=>{
  host.addEventListener(type, e=>{
    pointers.delete(e.pointerId);
    if(pointers.size<2) lastDist=null;
  });
});
host.addEventListener('wheel', e=>{
  e.preventDefault();
  const factor = e.deltaY<0 ? 1.08 : 0.92;
  const rect = host.getBoundingClientRect();
  zoomAt(e.clientX - rect.left, e.clientY - rect.top, factor);
},{passive:false});

// ---------- Спрайты (больше, мельче, «дрейф») ----------
class Sprite{
  constructor(img){
    this.img=img;
    this.reset(true);
  }
  reset(init=false){
    const t=performance.now();
    if(init){ this.x=rint(-2000,2000); this.y=rint(-2000,2000); this.s=BASE_SCALE; this.r=0; this.a=.6; this.blend='source-over'; this.inv=0; }
    this.tx = this.x + rint(-400,400);
    this.ty = this.y + rint(-400,400);
    this.ts = BASE_SCALE * (0.6 + rand()*0.9);
    this.tr = (rand()*Math.PI*2) * (rand()<0.5?1:0.25);
    this.ta = 0.20 + rand()*0.65;
    this.tblend = rpick(BLENDS);
    this.tinv = rand()<0.18 ? 1 : 0;
    this.tStart = t;
    this.tEnd = t + RETARGET_MS + rint(-600,600);
  }
  step(now){
    const k = Math.min(1, (now - this.tStart)/(this.tEnd - this.tStart));
    const e = ease(k);
    this.x = lerp(this.x, this.tx, e*0.05);
    this.y = lerp(this.y, this.ty, e*0.05);
    this.s = lerp(this.s, this.ts, e*0.06);
    this.r = lerp(this.r, this.tr, e*0.05);
    this.a = lerp(this.a, this.ta, e*0.06);
    if(k>=1) this.reset();
  }
  draw(now){
    const dw=this.img.width*this.s, dh=this.img.height*this.s;
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.r + Math.sin(now*0.0003)*0.12);
    if(rand()<0.06) ctx.scale(-1,1);
    ctx.globalCompositeOperation = this.tblend;
    ctx.globalAlpha = this.a;

    const inv = this.tinv ? 'invert(1)' : 'invert(0)';
    const sat = `saturate(${180 + Math.floor(80*Math.sin(now*0.0008))}%)`;
    const con = `contrast(${120 + Math.floor(60*Math.cos(now*0.0009))}%)`;
    const hue = `hue-rotate(${Math.floor((n1(now,1)+2)*90)}deg)`;
    const blur= rand()<(isMobile?0.04:0.06) ? `blur(${rint(1,2)}px)` : 'blur(0px)';
    ctx.filter = [inv,hue,sat,con,blur].join(' ');
    ctx.drawImage(this.img, -dw/2, -dh/2, dw, dh);
    ctx.restore();

    if(rand()<(isMobile?0.03:0.05)){
      const slices = rint(2, isMobile?4:6);
      for(let i=0;i<slices;i++){
        const sy = rint(0, this.img.height-1);
        const sh = rint(2, Math.max(4, Math.floor(this.img.height*0.05)));
        const jitter = rint(-Math.floor(dw*0.15), Math.floor(dw*0.15));
        ctx.save();
        ctx.globalCompositeOperation = rpick(['difference','exclusion','color-dodge','plus-lighter']);
        ctx.globalAlpha = 0.25 + rand()*0.4;
        ctx.filter = `hue-rotate(${rint(-20,20)}deg) saturate(220%) contrast(130%)`;
        ctx.drawImage(this.img, 0, sy, this.img.width, sh, -dw/2 + jitter, -dh/2 + sy*this.s, this.img.width*this.s, sh*this.s);
        ctx.restore();
      }
    }
  }
}

const sprites=[];
function populate(){
  sprites.length=0;
  const count = Math.max(16, Math.min(MAX_SPRITES, images.length*4));
  for(let i=0;i<count;i++){ sprites.push(new Sprite(images[rint(0,images.length-1)])); }
}

// ---------- Бесконечный холст (тайлинг вокруг камеры) ----------
function drawInfinite(now){
  const W=canvas.width/DPR, H=canvas.height/DPR;
  // Камера -> экран
  ctx.setTransform(DPR,0,0,DPR,0,0);
  ctx.globalCompositeOperation='source-over';
  ctx.globalAlpha = 1; ctx.filter='none';
  ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H);

  // Применяем камеру
  ctx.save();
  ctx.translate(W/2, H/2);
  ctx.scale(camera.z, camera.z);
  ctx.translate(-camera.x, -camera.y);

  // Опорный шаг тайлинга: крупная сетка
  const TILE = 1200; // размер тайла мира
  const cx = Math.floor(camera.x / TILE);
  const cy = Math.floor(camera.y / TILE);
  // Рисуем вокруг текущего тайла 3×3, создавая бесконечный эффект
  for(let ty=cy-1; ty<=cy+1; ty++){
    for(let tx=cx-1; tx<=cx+1; tx++){
      ctx.save();
      ctx.translate(tx*TILE, ty*TILE);
      // Отрисовка всех спрайтов, локально к тайлу
      for(const s of sprites){ s.step(now); s.draw(now); }
      ctx.restore();
    }
  }
  ctx.restore();

  // Виньетка
  const grd=ctx.createRadialGradient(W/2,H/2,Math.min(W,H)*0.2, W/2,H/2,Math.max(W,H)*0.7);
  grd.addColorStop(0,'rgba(0,0,0,0)');
  grd.addColorStop(1,'rgba(0,0,0,0.18)');
  ctx.globalCompositeOperation='multiply';
  ctx.filter='none';
  ctx.fillStyle=grd; ctx.fillRect(0,0,W,H);
}

// ---------- Инерция камеры ----------
function integrateCamera(){
  camera.x += camera.vx;
  camera.y += camera.vy;
  camera.vx *= camera.friction;
  camera.vy *= camera.friction;
  if(Math.abs(camera.vx)<0.01) camera.vx=0;
  if(Math.abs(camera.vy)<0.01) camera.vy=0;
}

// ---------- Цикл ----------
let running=true;
function tick(ts){
  if(!running){ requestAnimationFrame(tick); return; }
  integrateCamera();
  drawInfinite(ts);
  requestAnimationFrame(tick);
}

// ---------- UI ----------
document.getElementById('toggle').addEventListener('click',()=>{
  running=!running;
  document.getElementById('toggle').textContent = running?'Пауза':'Старт';
  if(running) requestAnimationFrame(tick);
});
document.getElementById('reroll').addEventListener('click',()=>{
  seed=Math.floor(Math.random()*1e9);
  populate();
});

// ---------- Старт ----------
function startRender(){
  fitSquare();
  populate();
  requestAnimationFrame(tick);
}
(async function init(){
  fitSquare();
  await loadAllProgressive();
})();
})();
</script>
</body>
</html>
